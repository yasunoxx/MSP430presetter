
main.elf:     file format elf32-msp430

SYMBOL TABLE:
0000ffe4 l    d  __interrupt_vector_3	00000000 __interrupt_vector_3
0000ffea l    d  __interrupt_vector_6	00000000 __interrupt_vector_6
0000ffee l    d  __interrupt_vector_8	00000000 __interrupt_vector_8
0000fff0 l    d  __interrupt_vector_9	00000000 __interrupt_vector_9
0000fff2 l    d  __interrupt_vector_10	00000000 __interrupt_vector_10
0000fff4 l    d  __interrupt_vector_11	00000000 __interrupt_vector_11
0000fffe l    d  __reset_vector	00000000 __reset_vector
0000c000 l    d  .rodata	00000000 .rodata
0000c000 l    d  .rodata2	00000000 .rodata2
0000c000 l    d  .text	00000000 .text
00000200 l    d  .data	00000000 .data
00000208 l    d  .bss	00000000 .bss
00000266 l    d  .noinit	00000000 .noinit
00000266 l    d  .heap	00000000 .heap
00000000 l    d  .MSP430.attributes	00000000 .MSP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 spi_master.c
00000000 l    df *ABS*	00000000 io.c
00000000 l    df *ABS*	00000000 main.c
0000c02c l     F .text	0000001a ConfigureTimerPwm.part.0
00000000 l    df *ABS*	00000000 /usr/local/msp430-gcc/bin/../lib/gcc/msp430-elf/9.2.0/../../../../msp430-elf/lib/430/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
00000000 l    df *ABS*	00000000 crt_bss.o
00000000 l    df *ABS*	00000000 crt_movedata.o
00000000 l    df *ABS*	00000000 crt_main.o
00000000 l    df *ABS*	00000000 tlv.c
00000000 l    df *ABS*	00000000 spi_frontend.c
00000000 l    df *ABS*	00000000 lib_a-memcpy.o
00000000 l    df *ABS*	00000000 lib_a-memmove.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000001 g       *ABS*	00000000 IE2
0000c286 g     F .text	00000012 ADC10_ISR
00000022 g       *ABS*	00000000 P1DIR
00000064 g       *ABS*	00000000 UCA0MCTL
0000022e g     O .bss	00000014 TransmitBuffer
00000208 g     O .bss	00000001 ScreenScenario
00000053 g       *ABS*	00000000 BCSCTL3
0000c1ec g     F .text	00000046 TimerA1_ISR
000010f8 g       *ABS*	00000000 CALDCO_16MHZ
0000c0a8 g     F .text	0000002e initializeDCO
00000025 g       *ABS*	00000000 P1IE
00000218 g     O .bss	00000001 Var_CALBC1_12MHz
0000022d g     O .bss	00000001 TXByteCtr
0000c8ca g     F .text	0000004e memmove
000001b4 g       *ABS*	00000000 ADC10MEM
0000020d g     O .bss	00000001 ClockMode
0000c8a0 g       .text	00000000 .hidden __mspabi_func_epilog_6
00000162 g       *ABS*	00000000 TA0CCTL0
00000024 g       *ABS*	00000000 P1IES
00000002 g       *ABS*	00000000 IFG1
0000c8ae g     F .text	0000001e memcpy
0000c872 g     F .text	0000001e SPI_ReadReg
00000217 g     O .bss	00000001 Var_CALDCO_8MHz
0000002a g       *ABS*	00000000 P2DIR
00000120 g       *ABS*	00000000 WDTCTL
00000216 g     O .bss	00000001 Var_CALBC1_8MHz
0000c000 g     F .text	00000004 __crt0_start
0000026a g       .heap	00000000 __HeapLimit
0000026a g       .heap	00000000 __heap_end__
0000c890 g     F .text	0000000e InitSPI_FrontEnd_GPIO
0000c68a g     F .text	0000002e SPI_Master_ReadReg
0000c004 g     F .text	0000000e __crt0_init_bss
0000005e g       *ABS*	00000000 __bsssize
00000224 g     O .bss	00000002 Var_CAL_ADC_15T30
00000219 g     O .bss	00000001 Var_CALDCO_12MHz
0000c8aa g       .text	00000000 .hidden __mspabi_func_epilog_1
00000220 g     O .bss	00000002 Var_CAL_ADC_25VREF_FACTOR
0000c8a6 g       .text	00000000 .hidden __mspabi_func_epilog_3
00000226 g     O .bss	00000002 Var_CAL_ADC_15VREF_FACTOR
0000006e g       *ABS*	00000000 UCB0RXBUF
0000c634 g     F .text	00000056 SPI_Master_WriteReg
00000228 g     O .bss	00000002 Var_CAL_ADC_OFFSET
000001b2 g       *ABS*	00000000 ADC10CTL1
0000025c g     O .bss	00000001 SlaveType0
0000021a g     O .bss	00000001 Var_CALBC1_16MHz
00000203 g     O .data	00000003 MCP23S17_Init2
00000214 g     O .bss	00000001 Var_CALBC1_1MHz
0000c734 g     F .text	0000010e USCIB0RX_ISR
0000006b g       *ABS*	00000000 UCB0BR1
00000266 g       .noinit	00000000 end
0000020a g     O .bss	00000002 ScreenWait
0000c242 g     F .text	00000018 ConfigureAdcTempSensor
00000026 g       *ABS*	00000000 P1SEL
00000041 g       *ABS*	00000000 P1SEL2
0000c852 g     F .text	00000020 SPI_WriteReg
0000021c g     O .bss	00000002 Var_CAL_ADC_25T85
0000c000 g       .text	00000000 _start
0000021b g     O .bss	00000001 Var_CALDCO_16MHz
0000022a g     O .bss	00000002 Var_CAL_ADC_GAIN_FACTOR
00000056 g       *ABS*	00000000 DCOCTL
0000025d g     O .bss	00000002 SlaveType1
00000258 g     O .bss	00000001 TransmitRegAddr
00000172 g       *ABS*	00000000 TA0CCR0
00000242 g     O .bss	00000001 ReceiveIndex
0000020e g     O .bss	00000002 LcdWait
00000008 g       *ABS*	00000000 __romdatacopysize
0000c616 g     F .text	0000001e CopyArray
00000003 g       *ABS*	00000000 IFG2
00000029 g       *ABS*	00000000 P2OUT
0000c298 g     F .text	00000380 GetTLV
00000212 g     O .bss	00000002 TempReg
00000000  w      *ABS*	00000000 __rom_highdatacopysize
0000c910 g     F .text	00000014 memset
00000069 g       *ABS*	00000000 UCB0CTL1
0000c0d6 g     F .text	00000110 main
00000266 g       .heap	00000000 __heap_start__
00000210 g     O .bss	00000002 SysTimer_Counter
0000c046 g     F .text	00000016 PreApplicationMode
00000000  w      *ABS*	00000000 __high_bsssize
000010f9 g       *ABS*	00000000 CALBC1_16MHZ
00000160 g       *ABS*	00000000 TA0CTL
00000000  w      *ABS*	00000000 __rom_highdatastart
0000c266 g     F .text	00000012 InitializeLeds
00000000 g       *ABS*	00000000 IE1
0000c6c8 g     F .text	0000001c InitClockTo16MHz
0000c232 g     F .text	00000010 WDT_ISR
00000215 g     O .bss	00000001 Var_CALDCO_1MHz
0000c6e4 g     F .text	0000002c InitSPI_GPIO
0000006f g       *ABS*	00000000 UCB0TXBUF
0000022c g     O .bss	00000001 TransmitIndex
0000c922 g       *ABS*	00000000 __romdatastart
0000c05c g     F .text	00000028 ConfigureTimerPwm
0000c278 g     F .text	0000000e InitializeButton
00000244 g     O .bss	00000014 ReceiveBuffer
0000c084 g     F .text	00000024 InitializeClocks
00000206 g     O .data	00000002 MCP23S17_Init1
000001b0 g       *ABS*	00000000 ADC10CTL0
00000021 g       *ABS*	00000000 P1OUT
00000058 g       *ABS*	00000000 BCSCTL2
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
0000c710 g     F .text	00000024 InitSPI
00000208 g       .bss	00000000 __bssstart
0000c8a2 g       .text	00000000 .hidden __mspabi_func_epilog_5
00000243 g     O .bss	00000001 RXByteCtr
00000400 g       .MSP430.attributes	00000000 __stack
00000208 g       .data	00000000 _edata
00000266 g       .heap	00000000 _end
00000164 g       *ABS*	00000000 TA0CCTL1
0000020c g     O .bss	00000001 F_SysTimer_Flipper
00000057 g       *ABS*	00000000 BCSCTL1
00000000  w      *ABS*	00000000 __high_bssstart
00000027 g       *ABS*	00000000 P1REN
0000021e g     O .bss	00000002 Var_CAL_ADC_25T30
0000025a g     O .bss	00000002 MasterMode
0000c1e6 g     F .text	00000006 TimerA0_ISR
0000c842 g     F .text	00000010 Port_1
0000c026 g     F .text	00000006 __crt0_call_main
0000c25a g     F .text	0000000c SampleAndConversionAdcTemp
0000025f g     O .bss	00000006 SlaveType2
00000200 g     O .data	00000003 MCP23S17_Init3
0000006a g       *ABS*	00000000 UCB0BR0
00000068 g       *ABS*	00000000 UCB0CTL0
00000222 g     O .bss	00000002 Var_CAL_ADC_15T85
00000200 g       .data	00000000 __datastart
0000c012 g     F .text	00000014 __crt0_movedata
0000c8a8 g       .text	00000000 .hidden __mspabi_func_epilog_2
0000c6b8 g     F .text	00000010 SendUCB0Data
00000023 g       *ABS*	00000000 P1IFG
0000c89e g       .text	00000000 .hidden __mspabi_func_epilog_7
0000c8a4 g       .text	00000000 .hidden __mspabi_func_epilog_4



Disassembly of section __interrupt_vector_3:

0000ffe4 <__interrupt_vector_3>:
    ffe4:	42 c8       	interrupt service routine at 0xc842

Disassembly of section __interrupt_vector_6:

0000ffea <__interrupt_vector_6>:
    ffea:	86 c2       	interrupt service routine at 0xc286

Disassembly of section __interrupt_vector_8:

0000ffee <__interrupt_vector_8>:
    ffee:	34 c7       	interrupt service routine at 0xc734

Disassembly of section __interrupt_vector_9:

0000fff0 <__interrupt_vector_9>:
    fff0:	ec c1       	interrupt service routine at 0xc1ec

Disassembly of section __interrupt_vector_10:

0000fff2 <__interrupt_vector_10>:
    fff2:	e6 c1       	interrupt service routine at 0xc1e6

Disassembly of section __interrupt_vector_11:

0000fff4 <__interrupt_vector_11>:
    fff4:	32 c2       	interrupt service routine at 0xc232

Disassembly of section .text:

0000c000 <__crt0_start>:
    c000:	31 40 00 04 	mov	#1024,	r1	;#0x0400

0000c004 <__crt0_init_bss>:
    c004:	3c 40 08 02 	mov	#520,	r12	;#0x0208

0000c008 <.Loc.76.1>:
    c008:	0d 43       	clr	r13		;

0000c00a <.Loc.77.1>:
    c00a:	3e 40 5e 00 	mov	#94,	r14	;#0x005e

0000c00e <.Loc.81.1>:
    c00e:	b0 12 10 c9 	call	#-14064	;#0xc910

0000c012 <__crt0_movedata>:
    c012:	3c 40 00 02 	mov	#512,	r12	;#0x0200

0000c016 <.Loc.116.1>:
    c016:	3d 40 22 c9 	mov	#-14046,r13	;#0xc922

0000c01a <.Loc.119.1>:
    c01a:	0d 9c       	cmp	r12,	r13	;

0000c01c <.Loc.120.1>:
    c01c:	04 24       	jz	$+10     	;abs 0xc026

0000c01e <.Loc.122.1>:
    c01e:	3e 40 08 00 	mov	#8,	r14	;

0000c022 <.Loc.124.1>:
    c022:	b0 12 ca c8 	call	#-14134	;#0xc8ca

0000c026 <__crt0_call_main>:
    c026:	0c 43       	clr	r12		;

0000c028 <.Loc.254.1>:
    c028:	b0 12 d6 c0 	call	#-16170	;#0xc0d6

0000c02c <ConfigureTimerPwm.part.0>:

void ConfigureTimerPwm( void )
{
  if( ClockMode == Low )
  {
    TACCR0 = TIMER_PWM_PERIOD;			// Compare Maxim value
    c02c:	b2 40 3c 00 	mov	#60,	&0x0172	;#0x003c
    c030:	72 01 

0000c032 <.Loc.159.1>:
#ifdef TARGET_XT1
    TACTL = TASSEL_2 | MC_1;				// TACLK = SMCLK, Up mode.
#else
    TACTL = TASSEL_2 | MC_1;				// TACLK = ACLK, Up mode.
    c032:	b2 40 10 02 	mov	#528,	&0x0160	;#0x0210
    c036:	60 01 

0000c038 <.Loc.161.1>:
#endif
    TACCTL0 = CCIE;									// TACCTL0 output OUT bit(not used)
    c038:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    c03c:	62 01 

0000c03e <.Loc.162.1>:
    TACCTL1 = CCIE + OUTMOD_3;			// TACCTL1 Capture Compare, Set/reset
    c03e:	b2 40 70 00 	mov	#112,	&0x0164	;#0x0070
    c042:	64 01 

0000c044 <.Loc.171.1>:
    TACCR0 = TIMER_PWM_PERIOD_DCO;	// Compare Maxim value
		TACTL = TASSEL_2 | MC_1;				// TACLK = SMCLK, Up mode.
		TACCTL0 = CCIE;									// TACCTL0 output OUT bit(not used)
		TACCTL1 = CCIE + OUTMOD_3;			// TACCTL1 Capture Compare, Set/reset
	}
}
    c044:	30 41       	ret			

0000c046 <PreApplicationMode>:
  SysTimer_Counter = 0;
    c046:	82 43 10 02 	mov	#0,	&0x0210	;r3 As==00

0000c04a <.Loc.142.1>:
  F_SysTimer_Flipper = SYSTIMER_FLIP_OFF;
    c04a:	c2 43 0c 02 	mov.b	#0,	&0x020c	;r3 As==00

0000c04e <.Loc.143.1>:
  ClockMode = Low;
    c04e:	c2 43 0d 02 	mov.b	#0,	&0x020d	;r3 As==00

0000c052 <.Loc.145.1>:
  ScreenWait = 0;
    c052:	82 43 0a 02 	mov	#0,	&0x020a	;r3 As==00

0000c056 <.Loc.146.1>:
  ScreenScenario = 0;
    c056:	c2 43 08 02 	mov.b	#0,	&0x0208	;r3 As==00

0000c05a <.Loc.149.1>:
}
    c05a:	30 41       	ret			

0000c05c <ConfigureTimerPwm>:
  if( ClockMode == Low )
    c05c:	5c 42 0d 02 	mov.b	&0x020d,r12	;0x020d

0000c060 <.Loc.153.1>:
    c060:	0c 93       	cmp	#0,	r12	;r3 As==00
    c062:	03 20       	jnz	$+8      	;abs 0xc06a
    c064:	b0 12 2c c0 	call	#-16340	;#0xc02c

0000c068 <.LVL0>:
}
    c068:	30 41       	ret			

0000c06a <.L5>:
    TACCR0 = TIMER_PWM_PERIOD_DCO;	// Compare Maxim value
    c06a:	b2 40 60 ea 	mov	#-5536,	&0x0172	;#0xea60
    c06e:	72 01 

0000c070 <.Loc.167.1>:
		TACTL = TASSEL_2 | MC_1;				// TACLK = SMCLK, Up mode.
    c070:	b2 40 10 02 	mov	#528,	&0x0160	;#0x0210
    c074:	60 01 

0000c076 <.Loc.168.1>:
		TACCTL0 = CCIE;									// TACCTL0 output OUT bit(not used)
    c076:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    c07a:	62 01 

0000c07c <.Loc.169.1>:
		TACCTL1 = CCIE + OUTMOD_3;			// TACCTL1 Capture Compare, Set/reset
    c07c:	b2 40 70 00 	mov	#112,	&0x0164	;#0x0070
    c080:	64 01 

0000c082 <.Loc.171.1>:
}
    c082:	30 41       	ret			

0000c084 <InitializeClocks>:
      if( ( IFG1 & OFIFG ) == 0 ) break;
    }
    BCSCTL2 |= SELM_3;
  }
#else
  DCOCTL = 0;
    c084:	c2 43 56 00 	mov.b	#0,	&0x0056	;r3 As==00

0000c088 <.Loc.202.1>:
  BCSCTL1 = 0;
    c088:	c2 43 57 00 	mov.b	#0,	&0x0057	;r3 As==00

0000c08c <.Loc.203.1>:
  BCSCTL1 = XT2OFF | DIVA_0 | RSEL0;
    c08c:	f2 40 81 ff 	mov.b	#-127,	&0x0057	;#0xff81
    c090:	57 00 

0000c092 <.Loc.205.1>:
                          // Set ACLK / 1
  BCSCTL2 = 0;
    c092:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00

0000c096 <.Loc.206.1>:
  BCSCTL2 = SELM_3 | DIVM_0 | SELS | DIVS_0;
    c096:	f2 40 c8 ff 	mov.b	#-56,	&0x0058	;#0xffc8
    c09a:	58 00 

0000c09c <.Loc.208.1>:
                          // SMCLK = MCLK = ACLK = 12kHz
  BCSCTL3 = 0;
    c09c:	c2 43 53 00 	mov.b	#0,	&0x0053	;r3 As==00

0000c0a0 <.Loc.209.1>:
  BCSCTL3 = LFXT1S_2; // use VLO
    c0a0:	f2 40 20 00 	mov.b	#32,	&0x0053	;#0x0020
    c0a4:	53 00 

0000c0a6 <.Loc.211.1>:
#endif
}
    c0a6:	30 41       	ret			

0000c0a8 <initializeDCO>:

void initializeDCO( void )
{
  DCOCTL = Var_CALDCO_12MHz;
    c0a8:	d2 42 19 02 	mov.b	&0x0219,&0x0056	;0x0219
    c0ac:	56 00 

0000c0ae <.Loc.216.1>:
  DCOCTL |= DCO2;
    c0ae:	f2 d0 80 ff 	bis.b	#-128,	&0x0056	;#0xff80
    c0b2:	56 00 

0000c0b4 <.Loc.217.1>:
  BCSCTL1 = Var_CALBC1_12MHz;
    c0b4:	d2 42 18 02 	mov.b	&0x0218,&0x0057	;0x0218
    c0b8:	57 00 

0000c0ba <.Loc.218.1>:
  BCSCTL1 |= DIVA_0;
  BCSCTL2 &= ~( DIVS_3 );
    c0ba:	f2 f0 f9 ff 	and.b	#-7,	&0x0058	;#0xfff9
    c0be:	58 00 

0000c0c0 <.Loc.220.1>:
  BCSCTL2 = SELM_0 | DIVM_0; // DCO = MCLK = SMCLK = ACLK(12MHZ, VLO * 1000)
    c0c0:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00

0000c0c4 <.Loc.221.1>:
  TACTL = TASSEL_2 | MC_2 | TACLR;
    c0c4:	b2 40 24 02 	mov	#548,	&0x0160	;#0x0224
    c0c8:	60 01 

0000c0ca <.Loc.223.1>:
      // Select SMCKL as source, no divider, Continuous mode and reset timer
  BCSCTL1 |= XT2OFF; // XT2 off, and Set ACLK to /1 divider
    c0ca:	f2 d0 80 ff 	bis.b	#-128,	&0x0057	;#0xff80
    c0ce:	57 00 

0000c0d0 <.Loc.225.1>:

  ClockMode = High;
    c0d0:	d2 43 0d 02 	mov.b	#1,	&0x020d	;r3 As==01

0000c0d4 <.Loc.226.1>:
}
    c0d4:	30 41       	ret			

0000c0d6 <main>:
{
    c0d6:	0a 12       	push	r10		;

0000c0d8 <.LCFI0>:
	WDTCTL = WDTPW + WDTHOLD;  // Stop WDT
    c0d8:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c0dc:	20 01 

0000c0de <.LBB10>:
  DCOCTL = 0;
    c0de:	c2 43 56 00 	mov.b	#0,	&0x0056	;r3 As==00

0000c0e2 <.Loc.202.1>:
  BCSCTL1 = 0;
    c0e2:	c2 43 57 00 	mov.b	#0,	&0x0057	;r3 As==00

0000c0e6 <.Loc.203.1>:
  BCSCTL1 = XT2OFF | DIVA_0 | RSEL0;
    c0e6:	f2 40 81 ff 	mov.b	#-127,	&0x0057	;#0xff81
    c0ea:	57 00 

0000c0ec <.Loc.205.1>:
  BCSCTL2 = 0;
    c0ec:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00

0000c0f0 <.Loc.206.1>:
  BCSCTL2 = SELM_3 | DIVM_0 | SELS | DIVS_0;
    c0f0:	f2 40 c8 ff 	mov.b	#-56,	&0x0058	;#0xffc8
    c0f4:	58 00 

0000c0f6 <.Loc.208.1>:
  BCSCTL3 = 0;
    c0f6:	c2 43 53 00 	mov.b	#0,	&0x0053	;r3 As==00

0000c0fa <.Loc.209.1>:
  BCSCTL3 = LFXT1S_2; // use VLO
    c0fa:	f2 40 20 00 	mov.b	#32,	&0x0053	;#0x0020
    c0fe:	53 00 

0000c100 <.LBE10>:
	InitializeButton();
    c100:	b0 12 78 c2 	call	#-15752	;#0xc278

0000c104 <.LVL1>:
	InitializeLeds();
    c104:	b0 12 66 c2 	call	#-15770	;#0xc266

0000c108 <.LBB12>:
  SysTimer_Counter = 0;
    c108:	82 43 10 02 	mov	#0,	&0x0210	;r3 As==00

0000c10c <.Loc.142.1>:
  F_SysTimer_Flipper = SYSTIMER_FLIP_OFF;
    c10c:	c2 43 0c 02 	mov.b	#0,	&0x020c	;r3 As==00

0000c110 <.Loc.143.1>:
  ClockMode = Low;
    c110:	c2 43 0d 02 	mov.b	#0,	&0x020d	;r3 As==00

0000c114 <.Loc.145.1>:
  ScreenWait = 0;
    c114:	82 43 0a 02 	mov	#0,	&0x020a	;r3 As==00

0000c118 <.Loc.146.1>:
  ScreenScenario = 0;
    c118:	c2 43 08 02 	mov.b	#0,	&0x0208	;r3 As==00

0000c11c <.LBB14>:
  if( ClockMode == Low )
    c11c:	5c 42 0d 02 	mov.b	&0x020d,r12	;0x020d

0000c120 <.Loc.153.1>:
    c120:	0c 93       	cmp	#0,	r12	;r3 As==00
    c122:	52 20       	jnz	$+166    	;abs 0xc1c8
    c124:	3a 40 2c c0 	mov	#-16340,r10	;#0xc02c
    c128:	8a 12       	call	r10		;

0000c12a <.L11>:
	__enable_interrupt();
    c12a:	32 d2       	eint			

0000c12c <.Loc.109.1>:
	ConfigureAdcTempSensor();
    c12c:	b0 12 42 c2 	call	#-15806	;#0xc242

0000c130 <.LVL4>:
	GetTLV();
    c130:	b0 12 98 c2 	call	#-15720	;#0xc298

0000c134 <.LVL5>:
	__disable_interrupt();
    c134:	32 c2       	dint			
    c136:	03 43       	nop			

0000c138 <.Loc.112.1>:
	initializeDCO(); // on this file
    c138:	b0 12 a8 c0 	call	#-16216	;#0xc0a8

0000c13c <.LBB17>:
  if( ClockMode == Low )
    c13c:	5c 42 0d 02 	mov.b	&0x020d,r12	;0x020d

0000c140 <.Loc.153.1>:
    c140:	0c 93       	cmp	#0,	r12	;r3 As==00
    c142:	35 20       	jnz	$+108    	;abs 0xc1ae
    c144:	8a 12       	call	r10		;

0000c146 <.L13>:
	__enable_interrupt();
    c146:	32 d2       	eint			

0000c148 <.Loc.116.1>:
  InitSPI_GPIO();
    c148:	b0 12 e4 c6 	call	#-14620	;#0xc6e4

0000c14c <.LVL8>:
	InitSPI_FrontEnd_GPIO();
    c14c:	b0 12 90 c8 	call	#-14192	;#0xc890

0000c150 <.LVL9>:
	InitSPI();
    c150:	b0 12 10 c7 	call	#-14576	;#0xc710

0000c154 <.LVL10>:
	InitClockTo16MHz();
    c154:	b0 12 c8 c6 	call	#-14648	;#0xc6c8

0000c158 <.LVL11>:
	LED_OUT |= LED1;  // Runup
    c158:	d2 d3 21 00 	bis.b	#1,	&0x0021	;r3 As==01

0000c15c <.Loc.126.1>:
	SPI_WriteReg( 1, DEVADDR_TARGET1_WRITE, MCP23S17_Init1, INIT1_LEN );
    c15c:	3a 40 52 c8 	mov	#-14254,r10	;#0xc852
    c160:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c162:	3e 40 06 02 	mov	#518,	r14	;#0x0206
    c166:	7d 40 4a 00 	mov.b	#74,	r13	;#0x004a
    c16a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c16c:	8a 12       	call	r10		;

0000c16e <.LVL12>:
	SPI_WriteReg( 1, DEVADDR_TARGET1_WRITE, MCP23S17_Init2, INIT2_LEN );
    c16e:	7f 40 03 00 	mov.b	#3,	r15	;
    c172:	3e 40 03 02 	mov	#515,	r14	;#0x0203
    c176:	7d 40 4a 00 	mov.b	#74,	r13	;#0x004a
    c17a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c17c:	8a 12       	call	r10		;

0000c17e <.LVL13>:
	SPI_WriteReg( 1, DEVADDR_TARGET1_WRITE, MCP23S17_Init3, INIT3_LEN );
    c17e:	7f 40 03 00 	mov.b	#3,	r15	;
    c182:	3e 40 00 02 	mov	#512,	r14	;#0x0200
    c186:	7d 40 4a 00 	mov.b	#74,	r13	;#0x004a
    c18a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c18c:	8a 12       	call	r10		;

0000c18e <.LVL14>:
	SPI_ReadReg( 1, DEVADDR_TARGET1_READ, TYPE_2_LENGTH );
    c18e:	7e 40 06 00 	mov.b	#6,	r14	;
    c192:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    c196:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c198:	b0 12 72 c8 	call	#-14222	;#0xc872

0000c19c <.LVL15>:
  CopyArray(ReceiveBuffer, SlaveType2, TYPE_2_LENGTH );
    c19c:	7e 40 06 00 	mov.b	#6,	r14	;
    c1a0:	3d 40 5f 02 	mov	#607,	r13	;#0x025f
    c1a4:	3c 40 44 02 	mov	#580,	r12	;#0x0244
    c1a8:	b0 12 16 c6 	call	#-14826	;#0xc616

0000c1ac <.L14>:
	while( 1 )
    c1ac:	ff 3f       	jmp	$+0      	;abs 0xc1ac

0000c1ae <.L12>:
    TACCR0 = TIMER_PWM_PERIOD_DCO;	// Compare Maxim value
    c1ae:	b2 40 60 ea 	mov	#-5536,	&0x0172	;#0xea60
    c1b2:	72 01 

0000c1b4 <.Loc.167.1>:
		TACTL = TASSEL_2 | MC_1;				// TACLK = SMCLK, Up mode.
    c1b4:	b2 40 10 02 	mov	#528,	&0x0160	;#0x0210
    c1b8:	60 01 

0000c1ba <.Loc.168.1>:
		TACCTL0 = CCIE;									// TACCTL0 output OUT bit(not used)
    c1ba:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    c1be:	62 01 

0000c1c0 <.Loc.169.1>:
		TACCTL1 = CCIE + OUTMOD_3;			// TACCTL1 Capture Compare, Set/reset
    c1c0:	b2 40 70 00 	mov	#112,	&0x0164	;#0x0070
    c1c4:	64 01 
    c1c6:	bf 3f       	jmp	$-128    	;abs 0xc146

0000c1c8 <.L10>:
    TACCR0 = TIMER_PWM_PERIOD_DCO;	// Compare Maxim value
    c1c8:	b2 40 60 ea 	mov	#-5536,	&0x0172	;#0xea60
    c1cc:	72 01 

0000c1ce <.Loc.167.1>:
		TACTL = TASSEL_2 | MC_1;				// TACLK = SMCLK, Up mode.
    c1ce:	b2 40 10 02 	mov	#528,	&0x0160	;#0x0210
    c1d2:	60 01 

0000c1d4 <.Loc.168.1>:
		TACCTL0 = CCIE;									// TACCTL0 output OUT bit(not used)
    c1d4:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    c1d8:	62 01 

0000c1da <.Loc.169.1>:
		TACCTL1 = CCIE + OUTMOD_3;			// TACCTL1 Capture Compare, Set/reset
    c1da:	b2 40 70 00 	mov	#112,	&0x0164	;#0x0070
    c1de:	64 01 
    c1e0:	3a 40 2c c0 	mov	#-16340,r10	;#0xc02c
    c1e4:	a2 3f       	jmp	$-186    	;abs 0xc12a

0000c1e6 <TimerA0_ISR>:
void __attribute__ (( interrupt TIMER0_A0_VECTOR )) TimerA0_ISR( void )
#else
interrupt ( TIMER0_A0_VECTOR ) TimerA0_ISR( void )
#endif
{
  TACCTL0 &= ~CCIFG;
    c1e6:	92 c3 62 01 	bic	#1,	&0x0162	;r3 As==01

0000c1ea <.Loc.237.1>:
}
    c1ea:	00 13       	reti			

0000c1ec <TimerA1_ISR>:
#if __MSP430_HEADER_VERSION__ == 1210
void __attribute__ (( interrupt TIMER0_A1_VECTOR )) TimerA1_ISR( void )
#else
interrupt ( TIMER0_A1_VECTOR ) TimerA1_ISR( void )
#endif
{
    c1ec:	0d 12       	push	r13		;

0000c1ee <.LCFI1>:
    c1ee:	0c 12       	push	r12		;

0000c1f0 <.LCFI2>:
  SysTimer_Counter++;
    c1f0:	92 53 10 02 	inc	&0x0210		;

0000c1f4 <.Loc.246.1>:
  if( SysTimer_Counter >= SYSTIMER_COUNTUP )
    c1f4:	1c 42 10 02 	mov	&0x0210,r12	;0x0210

0000c1f8 <.Loc.246.1>:
    c1f8:	7d 40 63 00 	mov.b	#99,	r13	;#0x0063
    c1fc:	0d 9c       	cmp	r12,	r13	;
    c1fe:	09 2c       	jc	$+20     	;abs 0xc212

0000c200 <.Loc.248.1>:
  {
    if( F_SysTimer_Flipper == SYSTIMER_FLIP_OFF )
    c200:	c2 93 0c 02 	cmp.b	#0,	&0x020c	;r3 As==00
    c204:	0f 20       	jnz	$+32     	;abs 0xc224

0000c206 <.Loc.250.1>:
    {
      F_SysTimer_Flipper = SYSTIMER_FLIP_ON;
    c206:	d2 43 0c 02 	mov.b	#1,	&0x020c	;r3 As==01

0000c20a <.Loc.251.1>:
      LED_OUT |= LED1;
    c20a:	d2 d3 21 00 	bis.b	#1,	&0x0021	;r3 As==01

0000c20e <.Loc.258.1>:
    else
    {
      F_SysTimer_Flipper = SYSTIMER_FLIP_OFF;
      LED_OUT &= ~LED1;
    }
    SysTimer_Counter = 0;
    c20e:	82 43 10 02 	mov	#0,	&0x0210	;r3 As==00

0000c212 <.L17>:
  }

  LcdWait++;
    c212:	92 53 0e 02 	inc	&0x020e		;

0000c216 <.Loc.262.1>:
  ScreenWait++;
    c216:	92 53 0a 02 	inc	&0x020a		;

0000c21a <.Loc.264.1>:

  TACCTL1 &= ~CCIFG;
    c21a:	92 c3 64 01 	bic	#1,	&0x0164	;r3 As==01

0000c21e <.Loc.265.1>:
}
    c21e:	3c 41       	pop	r12		;

0000c220 <.LCFI3>:
    c220:	3d 41       	pop	r13		;

0000c222 <.LCFI4>:
    c222:	00 13       	reti			

0000c224 <.L18>:
      F_SysTimer_Flipper = SYSTIMER_FLIP_OFF;
    c224:	c2 43 0c 02 	mov.b	#0,	&0x020c	;r3 As==00

0000c228 <.Loc.256.1>:
      LED_OUT &= ~LED1;
    c228:	d2 c3 21 00 	bic.b	#1,	&0x0021	;r3 As==01

0000c22c <.Loc.258.1>:
    SysTimer_Counter = 0;
    c22c:	82 43 10 02 	mov	#0,	&0x0210	;r3 As==00
    c230:	f0 3f       	jmp	$-30     	;abs 0xc212

0000c232 <WDT_ISR>:
void __attribute__ (( interrupt WDT_VECTOR )) WDT_ISR( void )
#else
interrupt ( WDT_VECTOR ) WDT_ISR( void )
#endif
{
  IE1 &= ~WDTIE;  /* disable interrupt */
    c232:	d2 c3 00 00 	bic.b	#1,	&0x0000	;r3 As==01

0000c236 <.Loc.275.1>:
  IFG1 &= ~WDTIFG;  /* clear interrupt flag */
    c236:	d2 c3 02 00 	bic.b	#1,	&0x0002	;r3 As==01

0000c23a <.Loc.276.1>:
  WDTCTL = WDTPW + WDTHOLD;  /* put WDT back in hold state */
    c23a:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c23e:	20 01 

0000c240 <.Loc.277.1>:
}
    c240:	00 13       	reti			

0000c242 <ConfigureAdcTempSensor>:
volatile unsigned short TempReg;

void ConfigureAdcTempSensor( void )
{
  /* Configure ADC Temp Sensor Channel */
  ADC10CTL1 = INCH_10 + ADC10DIV_3 + SHS_1;
    c242:	b2 40 60 a4 	mov	#-23456,&0x01b2	;#0xa460
    c246:	b2 01 

0000c248 <.Loc.60.1>:
                        // Temp Sensor ADC10CLK/4, Timer_A.OUT1 Trigger
  ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + REF2_5V + ADC10ON;  // + ADC10IE;
    c248:	
0000c24a <L0^A>:
    c24a:	70 38       	jl	$+226    	;abs 0xc32c
    c24c:	
0000c24e <.Loc.61.1>:
  ADC10CTL0 &= ~ADC10IFG;
    c24e:	a2 c2 b0 01 	bic	#4,	&0x01b0	;r2 As==10

0000c252 <.Loc.62.1>:
  ADC10CTL0 |= ENC + ADC10SC;  // Sampling and conversion start
    c252:	b2 d0 03 00 	bis	#3,	&0x01b0	;
    c256:	b0 01 

0000c258 <.Loc.63.1>:
}
    c258:	30 41       	ret			

0000c25a <SampleAndConversionAdcTemp>:

unsigned short SampleAndConversionAdcTemp( void )
{
  unsigned short tempreg;

  tempreg = ADC10MEM;
    c25a:	1c 42 b4 01 	mov	&0x01b4,r12	;0x01b4

0000c25e <.Loc.70.1>:
  ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start
    c25e:	b2 d0 03 00 	bis	#3,	&0x01b0	;
    c262:	b0 01 

0000c264 <.Loc.71.1>:
  return tempreg;
}
    c264:	30 41       	ret			

0000c266 <InitializeLeds>:

void InitializeLeds( void )
{
  LED_DIR |= LED1 + LED2;
    c266:	f2 d0 41 00 	bis.b	#65,	&0x0022	;#0x0041
    c26a:	22 00 

0000c26c <.Loc.78.1>:
//  LED_OUT &= ~( LED1 + LED2 );
  LED_OUT &= ~LED1;
    c26c:	d2 c3 21 00 	bic.b	#1,	&0x0021	;r3 As==01

0000c270 <.Loc.79.1>:
  LED_OUT &= ~LED2;
    c270:	f2 f0 bf ff 	and.b	#-65,	&0x0021	;#0xffbf
    c274:	21 00 

0000c276 <.Loc.80.1>:
}
    c276:	30 41       	ret			

0000c278 <InitializeButton>:

void InitializeButton( void )   // Configure Push Button
{
  BUTTON_DIR &= ~BUTTON;
    c278:	f2 c2 22 00 	bic.b	#8,	&0x0022	;r2 As==11

0000c27c <.Loc.85.1>:
  BUTTON_OUT |= BUTTON;
    c27c:	f2 d2 21 00 	bis.b	#8,	&0x0021	;r2 As==11

0000c280 <.Loc.86.1>:
  BUTTON_REN |= BUTTON;
    c280:	f2 d2 27 00 	bis.b	#8,	&0x0027	;r2 As==11

0000c284 <.Loc.87.1>:
}
    c284:	30 41       	ret			

0000c286 <ADC10_ISR>:
void __attribute__ (( interrupt ADC10_VECTOR )) ADC10_ISR( void )
#else
interrupt ( ADC10_VECTOR ) ADC10_ISR( void )
#endif
{
  TempReg = ADC10MEM;
    c286:	92 42 b4 01 	mov	&0x01b4,&0x0212	;0x01b4
    c28a:	12 02 

0000c28c <.Loc.99.1>:
  ADC10CTL0 &= ~ADC10IFG;
    c28c:	a2 c2 b0 01 	bic	#4,	&0x01b0	;r2 As==10

0000c290 <.Loc.100.1>:
  ADC10CTL0 |= ENC + ADC10SC;
    c290:	b2 d0 03 00 	bis	#3,	&0x01b0	;
    c294:	b0 01 

0000c296 <.Loc.101.1>:
}
    c296:	00 13       	reti			

0000c298 <GetTLV>:
unsigned char Var_CALDCO_8MHz, Var_CALBC1_8MHz;
unsigned char Var_CALDCO_1MHz, Var_CALBC1_1MHz;


void GetTLV( void )
{
    c298:	0a 12       	push	r10		;

0000c29a <.LCFI0>:
    c29a:	09 12       	push	r9		;

0000c29c <.LCFI1>:
    c29c:	08 12       	push	r8		;

0000c29e <.LCFI2>:
    c29e:	07 12       	push	r7		;

0000c2a0 <.LCFI3>:
    c2a0:	06 12       	push	r6		;

0000c2a2 <.LCFI4>:
    c2a2:	05 12       	push	r5		;

0000c2a4 <.LCFI5>:
    c2a4:	04 12       	push	r4		;

0000c2a6 <.LCFI6>:
    c2a6:	31 80 58 00 	sub	#88,	r1	;#0x0058

0000c2aa <.LCFI7>:
  unsigned char data[ TLV_SIZE ];
  unsigned char count = 0;
  unsigned short checksum;

  memcpy( data, (void *)TLV_START, TLV_SIZE );  // Read TLV
    c2aa:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    c2ae:	3d 40 c0 10 	mov	#4288,	r13	;#0x10c0
    c2b2:	0c 41       	mov	r1,	r12	;
    c2b4:	3c 50 18 00 	add	#24,	r12	;#0x0018
    c2b8:	b0 12 ae c8 	call	#-14162	;#0xc8ae

0000c2bc <.LVL1>:

  // FIXME: add here CHECKSUM VALIDATION
  checksum = data[ count++ ];
  checksum += data[ count ++ ] << 8;
    c2bc:	5c 42 1b 02 	mov.b	&0x021b,r12	;0x021b
    c2c0:	81 4c 08 00 	mov	r12,	8(r1)	;
    c2c4:	5d 42 1a 02 	mov.b	&0x021a,r13	;0x021a
    c2c8:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    c2cc:	5e 42 19 02 	mov.b	&0x0219,r14	;0x0219
    c2d0:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    c2d4:	5f 42 18 02 	mov.b	&0x0218,r15	;0x0218
    c2d8:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e
    c2dc:	5c 42 17 02 	mov.b	&0x0217,r12	;0x0217
    c2e0:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    c2e4:	5d 42 16 02 	mov.b	&0x0216,r13	;0x0216
    c2e8:	81 4d 12 00 	mov	r13,	18(r1)	; 0x0012
    c2ec:	5e 42 15 02 	mov.b	&0x0215,r14	;0x0215
    c2f0:	81 4e 14 00 	mov	r14,	20(r1)	; 0x0014
    c2f4:	5f 42 14 02 	mov.b	&0x0214,r15	;0x0214
    c2f8:	81 4f 16 00 	mov	r15,	22(r1)	; 0x0016
    c2fc:	91 42 2a 02 	mov	&0x022a,0(r1)	;0x022a
    c300:	00 00 
    c302:	91 42 28 02 	mov	&0x0228,2(r1)	;0x0228
    c306:	02 00 
    c308:	91 42 26 02 	mov	&0x0226,4(r1)	;0x0226
    c30c:	04 00 
    c30e:	16 42 24 02 	mov	&0x0224,r6	;0x0224
    c312:	17 42 22 02 	mov	&0x0222,r7	;0x0222
    c316:	18 42 20 02 	mov	&0x0220,r8	;0x0220
    c31a:	19 42 1e 02 	mov	&0x021e,r9	;0x021e
    c31e:	1a 42 1c 02 	mov	&0x021c,r10	;0x021c
    c322:	5b 41 1a 00 	mov.b	26(r1),	r11	;0x0001a

0000c326 <.Loc.38.1>:
  memcpy( data, (void *)TLV_START, TLV_SIZE );  // Read TLV
    c326:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    c32a:	14 41 06 00 	mov	6(r1),	r4	;

0000c32e <.Loc.42.1>:
  checksum += data[ count ++ ] << 8;
    c32e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    c330:	6e 42       	mov.b	#4,	r14	;r2 As==10

0000c332 <.Loc.85.1>:
      Var_CALDCO_12MHz = data[ count++ ];
      Var_CALBC1_12MHz = data[ count++ ];
      Var_CALDCO_8MHz = data[ count++ ];
      Var_CALBC1_8MHz = data[ count++ ];
      Var_CALDCO_1MHz = data[ count++ ];
      Var_CALBC1_1MHz = data[ count++ ];
    c332:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c334 <.L2>:
    if( data[ count ] == TAG_EMPTY )
    c334:	4f 4e       	mov.b	r14,	r15	;

0000c336 <.Loc.46.1>:
    c336:	7b 90 fe ff 	cmp.b	#-2,	r11	;#0xfffe
    c33a:	63 24       	jz	$+200    	;abs 0xc402

0000c33c <.L3>:
    else if( data[ count ] == TAG_ADC10_1 )
    c33c:	7b 90 10 00 	cmp.b	#16,	r11	;#0x0010
    c340:	a7 24       	jz	$+336    	;abs 0xc490

0000c342 <.Loc.74.1>:
    else if( data[ count ] == TAG_DCO_30 )
    c342:	5b 93       	cmp.b	#1,	r11	;r3 As==01
    c344:	f7 23       	jnz	$-16     	;abs 0xc334

0000c346 <.LVL4>:
      Var_CALDCO_16MHz = data[ count++ ];
    c346:	7d 40 18 00 	mov.b	#24,	r13	;#0x0018
    c34a:	0d 51       	add	r1,	r13	;
    c34c:	0f 5d       	add	r13,	r15	;
    c34e:	6f 4f       	mov.b	@r15,	r15	;
    c350:	81 4f 08 00 	mov	r15,	8(r1)	;

0000c354 <.LVL5>:
    c354:	4d 4c       	mov.b	r12,	r13	;
    c356:	7d 50 03 00 	add.b	#3,	r13	;

0000c35a <.Loc.79.1>:
      Var_CALBC1_16MHz = data[ count++ ];
    c35a:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c35e <.Loc.79.1>:
    c35e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    c362:	0e 51       	add	r1,	r14	;
    c364:	0d 5e       	add	r14,	r13	;
    c366:	6d 4d       	mov.b	@r13,	r13	;
    c368:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

0000c36c <.LVL6>:
    c36c:	4d 4c       	mov.b	r12,	r13	;
    c36e:	6d 52       	add.b	#4,	r13	;r2 As==10

0000c370 <.Loc.80.1>:
      Var_CALDCO_12MHz = data[ count++ ];
    c370:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c374 <.Loc.80.1>:
    c374:	0d 5e       	add	r14,	r13	;
    c376:	6d 4d       	mov.b	@r13,	r13	;
    c378:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c

0000c37c <.LVL7>:
    c37c:	4d 4c       	mov.b	r12,	r13	;
    c37e:	7d 50 05 00 	add.b	#5,	r13	;

0000c382 <.Loc.81.1>:
      Var_CALBC1_12MHz = data[ count++ ];
    c382:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c386 <.Loc.81.1>:
    c386:	0d 5e       	add	r14,	r13	;
    c388:	6d 4d       	mov.b	@r13,	r13	;
    c38a:	81 4d 0e 00 	mov	r13,	14(r1)	; 0x000e

0000c38e <.LVL8>:
    c38e:	4d 4c       	mov.b	r12,	r13	;
    c390:	7d 50 06 00 	add.b	#6,	r13	;

0000c394 <.Loc.82.1>:
      Var_CALDCO_8MHz = data[ count++ ];
    c394:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c398 <.Loc.82.1>:
    c398:	0d 5e       	add	r14,	r13	;
    c39a:	6d 4d       	mov.b	@r13,	r13	;
    c39c:	81 4d 10 00 	mov	r13,	16(r1)	; 0x0010

0000c3a0 <.LVL9>:
    c3a0:	4d 4c       	mov.b	r12,	r13	;
    c3a2:	7d 50 07 00 	add.b	#7,	r13	;

0000c3a6 <.Loc.83.1>:
      Var_CALBC1_8MHz = data[ count++ ];
    c3a6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c3aa <.Loc.83.1>:
    c3aa:	0d 5e       	add	r14,	r13	;
    c3ac:	6d 4d       	mov.b	@r13,	r13	;
    c3ae:	81 4d 12 00 	mov	r13,	18(r1)	; 0x0012

0000c3b2 <.Loc.84.1>:
      Var_CALDCO_1MHz = data[ count++ ];
    c3b2:	4d 4c       	mov.b	r12,	r13	;
    c3b4:	7d 50 09 00 	add.b	#9,	r13	;
    c3b8:	4e 4d       	mov.b	r13,	r14	;

0000c3ba <.LVL10>:
      Var_CALBC1_8MHz = data[ count++ ];
    c3ba:	7d 53       	add.b	#-1,	r13	;r3 As==11

0000c3bc <.LVL11>:
      Var_CALDCO_1MHz = data[ count++ ];
    c3bc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c3c0 <.Loc.84.1>:
    c3c0:	7f 40 18 00 	mov.b	#24,	r15	;#0x0018
    c3c4:	0f 51       	add	r1,	r15	;
    c3c6:	0d 5f       	add	r15,	r13	;

0000c3c8 <.LVL12>:
    c3c8:	6d 4d       	mov.b	@r13,	r13	;
    c3ca:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

0000c3ce <.Loc.85.1>:
      Var_CALBC1_1MHz = data[ count++ ];
    c3ce:	7c 50 0a 00 	add.b	#10,	r12	;#0x000a
    c3d2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000c3d6 <.LVL13>:
    c3d6:	0d 4f       	mov	r15,	r13	;
    c3d8:	0d 5e       	add	r14,	r13	;
    c3da:	6d 4d       	mov.b	@r13,	r13	;
    c3dc:	81 4d 16 00 	mov	r13,	22(r1)	; 0x0016
    c3e0:	81 45 06 00 	mov	r5,	6(r1)	;

0000c3e4 <.L4>:
    }
    if( count >= TLV_SIZE ) break;
    c3e4:	7d 40 3f 00 	mov.b	#63,	r13	;#0x003f
    c3e8:	4d 9c       	cmp.b	r12,	r13	;
    c3ea:	17 28       	jnc	$+48     	;abs 0xc41a

0000c3ec <.L19>:
    c3ec:	7d 40 18 00 	mov.b	#24,	r13	;#0x0018
    c3f0:	0d 51       	add	r1,	r13	;
    c3f2:	0d 5c       	add	r12,	r13	;
    c3f4:	6b 4d       	mov.b	@r13,	r11	;
    c3f6:	4e 4c       	mov.b	r12,	r14	;
    c3f8:	6e 53       	incd.b	r14		;

0000c3fa <.LVL16>:
    if( data[ count ] == TAG_EMPTY )
    c3fa:	4f 4e       	mov.b	r14,	r15	;

0000c3fc <.Loc.46.1>:
    c3fc:	7b 90 fe ff 	cmp.b	#-2,	r11	;#0xfffe
    c400:	9d 23       	jnz	$-196    	;abs 0xc33c

0000c402 <.L17>:
      count++;
    c402:	5c 53       	inc.b	r12		;

0000c404 <.LVL18>:
      count += data[ count ];
    c404:	4d 4c       	mov.b	r12,	r13	;
    c406:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018
    c40a:	0c 51       	add	r1,	r12	;
    c40c:	0d 5c       	add	r12,	r13	;

0000c40e <.Loc.50.1>:
      count++;
    c40e:	6e 5d       	add.b	@r13,	r14	;
    c410:	4c 4e       	mov.b	r14,	r12	;

0000c412 <.LVL19>:
    if( count >= TLV_SIZE ) break;
    c412:	7d 40 3f 00 	mov.b	#63,	r13	;#0x003f
    c416:	4d 9c       	cmp.b	r12,	r13	;
    c418:	e9 2f       	jc	$-44     	;abs 0xc3ec

0000c41a <.L7>:
    c41a:	04 93       	cmp	#0,	r4	;r3 As==00
    c41c:	12 24       	jz	$+38     	;abs 0xc442
    c41e:	a2 41 2a 02 	mov	@r1,	&0x022a	;
    c422:	92 41 02 00 	mov	2(r1),	&0x0228	;
    c426:	28 02 
    c428:	92 41 04 00 	mov	4(r1),	&0x0226	;
    c42c:	26 02 
    c42e:	82 46 24 02 	mov	r6,	&0x0224	;
    c432:	82 47 22 02 	mov	r7,	&0x0222	;
    c436:	82 48 20 02 	mov	r8,	&0x0220	;
    c43a:	82 49 1e 02 	mov	r9,	&0x021e	;
    c43e:	82 4a 1c 02 	mov	r10,	&0x021c	;

0000c442 <.L8>:
    c442:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    c446:	20 24       	jz	$+66     	;abs 0xc488
    c448:	1e 41 08 00 	mov	8(r1),	r14	;
    c44c:	c2 4e 1b 02 	mov.b	r14,	&0x021b	;
    c450:	1f 41 0a 00 	mov	10(r1),	r15	;0x0000a
    c454:	c2 4f 1a 02 	mov.b	r15,	&0x021a	;
    c458:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    c45c:	c2 4c 19 02 	mov.b	r12,	&0x0219	;
    c460:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    c464:	c2 4d 18 02 	mov.b	r13,	&0x0218	;
    c468:	1e 41 10 00 	mov	16(r1),	r14	;0x00010
    c46c:	c2 4e 17 02 	mov.b	r14,	&0x0217	;
    c470:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    c474:	c2 4f 16 02 	mov.b	r15,	&0x0216	;
    c478:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    c47c:	c2 4c 15 02 	mov.b	r12,	&0x0215	;
    c480:	1d 41 16 00 	mov	22(r1),	r13	;0x00016
    c484:	c2 4d 14 02 	mov.b	r13,	&0x0214	;

0000c488 <.L1>:
  } // endwhile
}
    c488:	31 50 58 00 	add	#88,	r1	;#0x0058

0000c48c <.LCFI8>:
    c48c:	30 40 9e c8 	br	#0xc89e		;

0000c490 <.L18>:
      Var_CAL_ADC_GAIN_FACTOR = data[ count++ ];
    c490:	4d 4c       	mov.b	r12,	r13	;
    c492:	7d 50 03 00 	add.b	#3,	r13	;

0000c496 <.Loc.58.1>:
      Var_CAL_ADC_GAIN_FACTOR += data[ count++ ] << 8;
    c496:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c49a <.Loc.58.1>:
    c49a:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    c49e:	0e 51       	add	r1,	r14	;
    c4a0:	0d 5e       	add	r14,	r13	;

0000c4a2 <.Loc.58.1>:
    c4a2:	6d 4d       	mov.b	@r13,	r13	;
    c4a4:	0d 5d       	rla	r13		;
    c4a6:	0d 5d       	rla	r13		;
    c4a8:	0d 5d       	rla	r13		;
    c4aa:	0d 5d       	rla	r13		;
    c4ac:	0d 5d       	rla	r13		;
    c4ae:	0d 5d       	rla	r13		;
    c4b0:	0d 5d       	rla	r13		;
    c4b2:	0d 5d       	rla	r13		;

0000c4b4 <.Loc.57.1>:
      Var_CAL_ADC_GAIN_FACTOR = data[ count++ ];
    c4b4:	0f 5e       	add	r14,	r15	;

0000c4b6 <.Loc.58.1>:
      Var_CAL_ADC_GAIN_FACTOR += data[ count++ ] << 8;
    c4b6:	6f 4f       	mov.b	@r15,	r15	;
    c4b8:	0f 5d       	add	r13,	r15	;
    c4ba:	81 4f 00 00 	mov	r15,	0(r1)	;

0000c4be <.LVL22>:
      Var_CAL_ADC_OFFSET = data[ count++ ];
    c4be:	4d 4c       	mov.b	r12,	r13	;
    c4c0:	7d 50 05 00 	add.b	#5,	r13	;

0000c4c4 <.Loc.60.1>:
      Var_CAL_ADC_OFFSET += data[ count++ ] << 8;
    c4c4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c4c8 <.Loc.60.1>:
    c4c8:	0d 5e       	add	r14,	r13	;

0000c4ca <.Loc.60.1>:
    c4ca:	6e 4d       	mov.b	@r13,	r14	;
    c4cc:	0e 5e       	rla	r14		;
    c4ce:	0e 5e       	rla	r14		;
    c4d0:	0e 5e       	rla	r14		;
    c4d2:	0e 5e       	rla	r14		;
    c4d4:	0e 5e       	rla	r14		;
    c4d6:	0e 5e       	rla	r14		;
    c4d8:	0e 5e       	rla	r14		;
    c4da:	0e 5e       	rla	r14		;

0000c4dc <.Loc.58.1>:
      Var_CAL_ADC_GAIN_FACTOR += data[ count++ ] << 8;
    c4dc:	4d 4c       	mov.b	r12,	r13	;
    c4de:	6d 52       	add.b	#4,	r13	;r2 As==10

0000c4e0 <.Loc.59.1>:
      Var_CAL_ADC_OFFSET = data[ count++ ];
    c4e0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c4e4 <.Loc.59.1>:
    c4e4:	7f 40 18 00 	mov.b	#24,	r15	;#0x0018
    c4e8:	0f 51       	add	r1,	r15	;
    c4ea:	0d 5f       	add	r15,	r13	;

0000c4ec <.Loc.60.1>:
      Var_CAL_ADC_OFFSET += data[ count++ ] << 8;
    c4ec:	6d 4d       	mov.b	@r13,	r13	;
    c4ee:	0d 5e       	add	r14,	r13	;
    c4f0:	81 4d 02 00 	mov	r13,	2(r1)	;

0000c4f4 <.LVL23>:
      Var_CAL_ADC_15VREF_FACTOR = data[ count++ ];
    c4f4:	4d 4c       	mov.b	r12,	r13	;
    c4f6:	7d 50 07 00 	add.b	#7,	r13	;

0000c4fa <.Loc.62.1>:
      Var_CAL_ADC_15VREF_FACTOR += data[ count++ ] << 8;
    c4fa:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c4fe <.Loc.62.1>:
    c4fe:	0d 5f       	add	r15,	r13	;

0000c500 <.Loc.62.1>:
    c500:	6e 4d       	mov.b	@r13,	r14	;
    c502:	0e 5e       	rla	r14		;
    c504:	0e 5e       	rla	r14		;
    c506:	0e 5e       	rla	r14		;
    c508:	0e 5e       	rla	r14		;
    c50a:	0e 5e       	rla	r14		;
    c50c:	0e 5e       	rla	r14		;
    c50e:	0e 5e       	rla	r14		;
    c510:	0e 5e       	rla	r14		;

0000c512 <.Loc.60.1>:
      Var_CAL_ADC_OFFSET += data[ count++ ] << 8;
    c512:	4d 4c       	mov.b	r12,	r13	;
    c514:	7d 50 06 00 	add.b	#6,	r13	;

0000c518 <.Loc.61.1>:
      Var_CAL_ADC_15VREF_FACTOR = data[ count++ ];
    c518:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c51c <.Loc.61.1>:
    c51c:	0d 5f       	add	r15,	r13	;

0000c51e <.Loc.62.1>:
      Var_CAL_ADC_15VREF_FACTOR += data[ count++ ] << 8;
    c51e:	6d 4d       	mov.b	@r13,	r13	;
    c520:	0d 5e       	add	r14,	r13	;
    c522:	81 4d 04 00 	mov	r13,	4(r1)	;

0000c526 <.LVL24>:
      Var_CAL_ADC_15T30 = data[ count++ ];
    c526:	4d 4c       	mov.b	r12,	r13	;
    c528:	7d 50 09 00 	add.b	#9,	r13	;

0000c52c <.Loc.64.1>:
      Var_CAL_ADC_15T30 += data[ count++ ] << 8;
    c52c:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c530 <.Loc.64.1>:
    c530:	0d 5f       	add	r15,	r13	;

0000c532 <.Loc.64.1>:
    c532:	66 4d       	mov.b	@r13,	r6	;
    c534:	06 56       	rla	r6		;
    c536:	06 56       	rla	r6		;
    c538:	06 56       	rla	r6		;
    c53a:	06 56       	rla	r6		;
    c53c:	06 56       	rla	r6		;
    c53e:	06 56       	rla	r6		;
    c540:	06 56       	rla	r6		;
    c542:	06 56       	rla	r6		;

0000c544 <.Loc.62.1>:
      Var_CAL_ADC_15VREF_FACTOR += data[ count++ ] << 8;
    c544:	4d 4c       	mov.b	r12,	r13	;
    c546:	7d 52       	add.b	#8,	r13	;r2 As==11

0000c548 <.Loc.63.1>:
      Var_CAL_ADC_15T30 = data[ count++ ];
    c548:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c54c <.Loc.63.1>:
    c54c:	0d 5f       	add	r15,	r13	;

0000c54e <.Loc.64.1>:
      Var_CAL_ADC_15T30 += data[ count++ ] << 8;
    c54e:	6d 4d       	mov.b	@r13,	r13	;
    c550:	06 5d       	add	r13,	r6	;

0000c552 <.LVL25>:
      Var_CAL_ADC_15T85 = data[ count++ ];
    c552:	4d 4c       	mov.b	r12,	r13	;
    c554:	7d 50 0b 00 	add.b	#11,	r13	;#0x000b

0000c558 <.Loc.66.1>:
      Var_CAL_ADC_15T85 += data[ count++ ] << 8;
    c558:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c55c <.Loc.66.1>:
    c55c:	0d 5f       	add	r15,	r13	;

0000c55e <.Loc.66.1>:
    c55e:	67 4d       	mov.b	@r13,	r7	;
    c560:	07 57       	rla	r7		;
    c562:	07 57       	rla	r7		;
    c564:	07 57       	rla	r7		;
    c566:	07 57       	rla	r7		;
    c568:	07 57       	rla	r7		;
    c56a:	07 57       	rla	r7		;
    c56c:	07 57       	rla	r7		;
    c56e:	07 57       	rla	r7		;

0000c570 <.Loc.64.1>:
      Var_CAL_ADC_15T30 += data[ count++ ] << 8;
    c570:	4d 4c       	mov.b	r12,	r13	;
    c572:	7d 50 0a 00 	add.b	#10,	r13	;#0x000a

0000c576 <.Loc.65.1>:
      Var_CAL_ADC_15T85 = data[ count++ ];
    c576:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c57a <.Loc.65.1>:
    c57a:	0d 5f       	add	r15,	r13	;

0000c57c <.Loc.66.1>:
      Var_CAL_ADC_15T85 += data[ count++ ] << 8;
    c57c:	6d 4d       	mov.b	@r13,	r13	;
    c57e:	07 5d       	add	r13,	r7	;

0000c580 <.LVL26>:
      Var_CAL_ADC_25VREF_FACTOR = data[ count++ ];
    c580:	4d 4c       	mov.b	r12,	r13	;
    c582:	7d 50 0d 00 	add.b	#13,	r13	;#0x000d

0000c586 <.Loc.68.1>:
      Var_CAL_ADC_25VREF_FACTOR += data[ count++ ] << 8;
    c586:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c58a <.Loc.68.1>:
    c58a:	0d 5f       	add	r15,	r13	;

0000c58c <.Loc.68.1>:
    c58c:	68 4d       	mov.b	@r13,	r8	;
    c58e:	08 58       	rla	r8		;
    c590:	08 58       	rla	r8		;
    c592:	08 58       	rla	r8		;
    c594:	08 58       	rla	r8		;
    c596:	08 58       	rla	r8		;
    c598:	08 58       	rla	r8		;
    c59a:	08 58       	rla	r8		;
    c59c:	08 58       	rla	r8		;

0000c59e <.Loc.66.1>:
      Var_CAL_ADC_15T85 += data[ count++ ] << 8;
    c59e:	4d 4c       	mov.b	r12,	r13	;
    c5a0:	7d 50 0c 00 	add.b	#12,	r13	;#0x000c

0000c5a4 <.Loc.67.1>:
      Var_CAL_ADC_25VREF_FACTOR = data[ count++ ];
    c5a4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c5a8 <.Loc.67.1>:
    c5a8:	0d 5f       	add	r15,	r13	;

0000c5aa <.Loc.68.1>:
      Var_CAL_ADC_25VREF_FACTOR += data[ count++ ] << 8;
    c5aa:	6d 4d       	mov.b	@r13,	r13	;
    c5ac:	08 5d       	add	r13,	r8	;

0000c5ae <.LVL27>:
      Var_CAL_ADC_25T30 = data[ count++ ];
    c5ae:	4d 4c       	mov.b	r12,	r13	;
    c5b0:	7d 50 0f 00 	add.b	#15,	r13	;#0x000f

0000c5b4 <.Loc.70.1>:
      Var_CAL_ADC_25T30 += data[ count++ ] << 8;
    c5b4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c5b8 <.Loc.70.1>:
    c5b8:	0d 5f       	add	r15,	r13	;

0000c5ba <.Loc.70.1>:
    c5ba:	69 4d       	mov.b	@r13,	r9	;
    c5bc:	09 59       	rla	r9		;
    c5be:	09 59       	rla	r9		;
    c5c0:	09 59       	rla	r9		;
    c5c2:	09 59       	rla	r9		;
    c5c4:	09 59       	rla	r9		;
    c5c6:	09 59       	rla	r9		;
    c5c8:	09 59       	rla	r9		;
    c5ca:	09 59       	rla	r9		;

0000c5cc <.Loc.68.1>:
      Var_CAL_ADC_25VREF_FACTOR += data[ count++ ] << 8;
    c5cc:	4d 4c       	mov.b	r12,	r13	;
    c5ce:	7d 50 0e 00 	add.b	#14,	r13	;#0x000e

0000c5d2 <.Loc.69.1>:
      Var_CAL_ADC_25T30 = data[ count++ ];
    c5d2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c5d6 <.Loc.69.1>:
    c5d6:	0d 5f       	add	r15,	r13	;

0000c5d8 <.Loc.70.1>:
      Var_CAL_ADC_25T30 += data[ count++ ] << 8;
    c5d8:	6d 4d       	mov.b	@r13,	r13	;
    c5da:	09 5d       	add	r13,	r9	;

0000c5dc <.Loc.71.1>:
      Var_CAL_ADC_25T85 = data[ count++ ];
    c5dc:	4e 4c       	mov.b	r12,	r14	;
    c5de:	7e 50 11 00 	add.b	#17,	r14	;#0x0011
    c5e2:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

0000c5e6 <.LVL28>:
      Var_CAL_ADC_25T30 += data[ count++ ] << 8;
    c5e6:	4d 4c       	mov.b	r12,	r13	;
    c5e8:	7d 50 10 00 	add.b	#16,	r13	;#0x0010

0000c5ec <.Loc.71.1>:
      Var_CAL_ADC_25T85 = data[ count++ ];
    c5ec:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000c5f0 <.Loc.71.1>:
    c5f0:	0d 5f       	add	r15,	r13	;

0000c5f2 <.Loc.72.1>:
      Var_CAL_ADC_25T85 += data[ count++ ] << 8;
    c5f2:	7c 50 12 00 	add.b	#18,	r12	;#0x0012
    c5f6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000c5fa <.LVL29>:
    c5fa:	0e 5f       	add	r15,	r14	;

0000c5fc <.Loc.72.1>:
    c5fc:	6a 4e       	mov.b	@r14,	r10	;
    c5fe:	0a 5a       	rla	r10		;
    c600:	0a 5a       	rla	r10		;
    c602:	0a 5a       	rla	r10		;
    c604:	0a 5a       	rla	r10		;
    c606:	0a 5a       	rla	r10		;
    c608:	0a 5a       	rla	r10		;
    c60a:	0a 5a       	rla	r10		;
    c60c:	0a 5a       	rla	r10		;

0000c60e <.Loc.72.1>:
    c60e:	6d 4d       	mov.b	@r13,	r13	;
    c610:	0a 5d       	add	r13,	r10	;
    c612:	04 45       	mov	r5,	r4	;
    c614:	e7 3e       	jmp	$-560    	;abs 0xc3e4

0000c616 <CopyArray>:
SPI_Mode SPI_Master_ReadReg(uint8_t reg_addr, uint8_t count);
void CopyArray(uint8_t *source, uint8_t *dest, uint8_t count);
void SendUCB0Data(uint8_t val);

void CopyArray(uint8_t *source, uint8_t *dest, uint8_t count)
{
    c616:	4f 4e       	mov.b	r14,	r15	;

0000c618 <L0^A>:
    uint8_t copyIndex = 0;
    for (copyIndex = 0; copyIndex < count; copyIndex++)
    c618:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    c61a:	0b 24       	jz	$+24     	;abs 0xc632
    c61c:	0e 4c       	mov	r12,	r14	;

0000c61e <.LVL2>:
    c61e:	1e 53       	inc	r14		;
    c620:	7f 53       	add.b	#-1,	r15	;r3 As==11

0000c622 <.LVL3>:
    c622:	3f f0 ff 00 	and	#255,	r15	;#0x00ff
    c626:	0e 5f       	add	r15,	r14	;

0000c628 <.L3>:
    {
        dest[copyIndex] = source[copyIndex];
    c628:	fd 4c 00 00 	mov.b	@r12+,	0(r13)	;

0000c62c <.LVL5>:
    c62c:	1d 53       	inc	r13		;

0000c62e <.LVL6>:
    for (copyIndex = 0; copyIndex < count; copyIndex++)
    c62e:	0c 9e       	cmp	r14,	r12	;
    c630:	fb 23       	jnz	$-8      	;abs 0xc628

0000c632 <.L1>:
    }
}
    c632:	30 41       	ret			

0000c634 <SPI_Master_WriteReg>:


SPI_Mode SPI_Master_WriteReg(uint8_t reg_addr, uint8_t *reg_data, uint8_t count)
{
    c634:	0a 12       	push	r10		;

0000c636 <.LCFI0>:
    c636:	09 12       	push	r9		;

0000c638 <.LCFI1>:
    c638:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    c63c:	49 4e       	mov.b	r14,	r9	;

0000c63e <.Loc.122.1>:
    MasterMode = TX_REG_ADDRESS_MODE;
    c63e:	92 43 5a 02 	mov	#1,	&0x025a	;r3 As==01

0000c642 <.Loc.123.1>:
    TransmitRegAddr = reg_addr;
    c642:	c2 4c 58 02 	mov.b	r12,	&0x0258	;

0000c646 <.LBB17>:
    for (copyIndex = 0; copyIndex < count; copyIndex++)
    c646:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    c648:	0f 24       	jz	$+32     	;abs 0xc668
    c64a:	3e 40 2e 02 	mov	#558,	r14	;#0x022e

0000c64e <.LVL10>:
    c64e:	4a 49       	mov.b	r9,	r10	;
    c650:	7a 53       	add.b	#-1,	r10	;r3 As==11
    c652:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    c656:	0a 5d       	add	r13,	r10	;

0000c658 <.L11>:
        dest[copyIndex] = source[copyIndex];
    c658:	6b 4d       	mov.b	@r13,	r11	;
    c65a:	0f 4d       	mov	r13,	r15	;
    c65c:	1d 53       	inc	r13		;

0000c65e <.LVL12>:
    c65e:	ce 4b 00 00 	mov.b	r11,	0(r14)	;
    c662:	1e 53       	inc	r14		;

0000c664 <.LVL13>:
    for (copyIndex = 0; copyIndex < count; copyIndex++)
    c664:	0f 9a       	cmp	r10,	r15	;
    c666:	f8 23       	jnz	$-14     	;abs 0xc658

0000c668 <.L10>:

    //Copy register data to TransmitBuffer
    CopyArray(reg_data, TransmitBuffer, count);

    TXByteCtr = count;
    c668:	c2 49 2d 02 	mov.b	r9,	&0x022d	;

0000c66c <.Loc.129.1>:
    RXByteCtr = 0;
    c66c:	c2 43 43 02 	mov.b	#0,	&0x0243	;r3 As==00

0000c670 <.Loc.130.1>:
    ReceiveIndex = 0;
    c670:	c2 43 42 02 	mov.b	#0,	&0x0242	;r3 As==00

0000c674 <.Loc.131.1>:
    TransmitIndex = 0;
    c674:	c2 43 2c 02 	mov.b	#0,	&0x022c	;r3 As==00

0000c678 <.L12>:
    return MasterMode;
}

void SendUCB0Data(uint8_t val)
{
    while (!(IFG2 & UCB0TXIFG));              // USCI_A0 TX buffer ready?
    c678:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c67c:	fd 27       	jz	$-4      	;abs 0xc678

0000c67e <.Loc.163.1>:
    UCB0TXBUF = val;
    c67e:	c2 4c 6f 00 	mov.b	r12,	&0x006f	;

0000c682 <.LBE19>:
    __bis_SR_register(CPUOFF + GIE);              // Enter LPM0 w/ interrupts
    c682:	32 d0 18 00 	bis	#24,	r2	;#0x0018

0000c686 <.Loc.139.1>:
}
    c686:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c688 <.LVL17>:
    c688:	0f 3d       	jmp	$+544    	;abs 0xc8a8

0000c68a <SPI_Master_ReadReg>:
{
    c68a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000c68e <.Loc.144.1>:
    MasterMode = TX_REG_ADDRESS_MODE;
    c68e:	92 43 5a 02 	mov	#1,	&0x025a	;r3 As==01

0000c692 <.Loc.145.1>:
    TransmitRegAddr = reg_addr;
    c692:	c2 4c 58 02 	mov.b	r12,	&0x0258	;

0000c696 <.Loc.146.1>:
    RXByteCtr = count;
    c696:	c2 4d 43 02 	mov.b	r13,	&0x0243	;

0000c69a <.Loc.147.1>:
    TXByteCtr = 0;
    c69a:	c2 43 2d 02 	mov.b	#0,	&0x022d	;r3 As==00

0000c69e <.Loc.148.1>:
    ReceiveIndex = 0;
    c69e:	c2 43 42 02 	mov.b	#0,	&0x0242	;r3 As==00

0000c6a2 <.Loc.149.1>:
    TransmitIndex = 0;
    c6a2:	c2 43 2c 02 	mov.b	#0,	&0x022c	;r3 As==00

0000c6a6 <.L20>:
    while (!(IFG2 & UCB0TXIFG));              // USCI_A0 TX buffer ready?
    c6a6:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c6aa:	fd 27       	jz	$-4      	;abs 0xc6a6

0000c6ac <.Loc.163.1>:
    UCB0TXBUF = val;
    c6ac:	c2 4c 6f 00 	mov.b	r12,	&0x006f	;

0000c6b0 <.LBE21>:
    __bis_SR_register(CPUOFF + GIE);              // Enter LPM0 w/ interrupts
    c6b0:	32 d0 18 00 	bis	#24,	r2	;#0x0018

0000c6b4 <.Loc.157.1>:
}
    c6b4:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c6b6 <.LVL21>:
    c6b6:	30 41       	ret			

0000c6b8 <SendUCB0Data>:
{
    c6b8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000c6bc <.L24>:
    while (!(IFG2 & UCB0TXIFG));              // USCI_A0 TX buffer ready?
    c6bc:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c6c0:	fd 27       	jz	$-4      	;abs 0xc6bc

0000c6c2 <.Loc.163.1>:
    UCB0TXBUF = val;
    c6c2:	c2 4c 6f 00 	mov.b	r12,	&0x006f	;

0000c6c6 <.Loc.164.1>:
}
    c6c6:	30 41       	ret			

0000c6c8 <InitClockTo16MHz>:
// Device Initialization *******************************************************
//******************************************************************************

void InitClockTo16MHz()
{
    if (CALBC1_16MHZ==0xFF)                  // If calibration constant erased
    c6c8:	5c 42 f9 10 	mov.b	&0x10f9,r12	;0x10f9
    c6cc:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    c6ce:	09 24       	jz	$+20     	;abs 0xc6e2

0000c6d0 <.Loc.176.1>:
    {
        while(1);                               // do not load, trap CPU!!
    }
    DCOCTL = 0;                               // Select lowest DCOx and MODx settings
    c6d0:	c2 43 56 00 	mov.b	#0,	&0x0056	;r3 As==00

0000c6d4 <.Loc.177.1>:
    BCSCTL1 = CALBC1_16MHZ;                    // Set DCO
    c6d4:	d2 42 f9 10 	mov.b	&0x10f9,&0x0057	;0x10f9
    c6d8:	57 00 

0000c6da <.Loc.178.1>:
    DCOCTL = CALDCO_16MHZ;
    c6da:	d2 42 f8 10 	mov.b	&0x10f8,&0x0056	;0x10f8
    c6de:	56 00 

0000c6e0 <.Loc.179.1>:
}
    c6e0:	30 41       	ret			

0000c6e2 <.L29>:
        while(1);                               // do not load, trap CPU!!
    c6e2:	ff 3f       	jmp	$+0      	;abs 0xc6e2

0000c6e4 <InitSPI_GPIO>:
  //LEDs
//  P1OUT = 0x00;                             // P1 setup for LED & reset output
//  P1DIR |= BIT0 | BIT5 | BIT6;

  //SPI Pins
  P1SEL |= BIT5 | BIT6 | BIT7;
    c6e4:	f2 d0 e0 ff 	bis.b	#-32,	&0x0026	;#0xffe0
    c6e8:	26 00 

0000c6ea <.Loc.189.1>:
  P1SEL2 |= BIT5 | BIT6 | BIT7;
    c6ea:	f2 d0 e0 ff 	bis.b	#-32,	&0x0041	;#0xffe0
    c6ee:	41 00 

0000c6f0 <.Loc.191.1>:

  P1DIR |= BIT5 | BIT7;
    c6f0:	f2 d0 a0 ff 	bis.b	#-96,	&0x0022	;#0xffa0
    c6f4:	22 00 

0000c6f6 <.Loc.194.1>:

  //Button to initiate transfer
  P1DIR &= ~(BIT3);
    c6f6:	f2 c2 22 00 	bic.b	#8,	&0x0022	;r2 As==11

0000c6fa <.Loc.195.1>:
  P1OUT |= BIT3;                            // P1.3 pull up
    c6fa:	f2 d2 21 00 	bis.b	#8,	&0x0021	;r2 As==11

0000c6fe <.Loc.196.1>:
  P1REN |= BIT3;                            // P1.3 pull up/down resistor enable
    c6fe:	f2 d2 27 00 	bis.b	#8,	&0x0027	;r2 As==11

0000c702 <.Loc.197.1>:
  P1IE  |= BIT3;                            // P1.3 interrupt enabled
    c702:	f2 d2 25 00 	bis.b	#8,	&0x0025	;r2 As==11

0000c706 <.Loc.198.1>:
  P1IES |= BIT3;                            // P1.3 Hi/lo edge
    c706:	f2 d2 24 00 	bis.b	#8,	&0x0024	;r2 As==11

0000c70a <.Loc.199.1>:
  P1IFG &= ~BIT3;                           // P1.3 IFG cleared
    c70a:	f2 c2 23 00 	bic.b	#8,	&0x0023	;r2 As==11

0000c70e <.Loc.200.1>:
}
    c70e:	30 41       	ret			

0000c710 <InitSPI>:

void InitSPI()
{
  //Clock Polarity: The inactive state is high
  //MSB First, 8-bit, Master, 3-pin mode, Synchronous
  UCB0CTL0 |= UCCKPL + UCMSB + UCMST + UCSYNC;
    c710:	f2 d0 69 00 	bis.b	#105,	&0x0068	;#0x0069
    c714:	68 00 

0000c716 <.Loc.207.1>:
  UCB0CTL1 |= UCSSEL_2;                     // SMCLK
    c716:	f2 d0 80 ff 	bis.b	#-128,	&0x0069	;#0xff80
    c71a:	69 00 

0000c71c <.Loc.208.1>:
  UCB0BR0 |= 0x20;                          // /2
    c71c:	f2 d0 20 00 	bis.b	#32,	&0x006a	;#0x0020
    c720:	6a 00 

0000c722 <.Loc.209.1>:
  UCB0BR1 = 0;                              //
    c722:	c2 43 6b 00 	mov.b	#0,	&0x006b	;r3 As==00

0000c726 <.Loc.210.1>:
  UCA0MCTL = 0;                             // No modulation must be cleared for SPI
    c726:	c2 43 64 00 	mov.b	#0,	&0x0064	;r3 As==00

0000c72a <.Loc.211.1>:
  UCB0CTL1 &= ~UCSWRST;                     // **Initialize USCI state machine**
    c72a:	d2 c3 69 00 	bic.b	#1,	&0x0069	;r3 As==01

0000c72e <.Loc.212.1>:
  IE2 |= UCB0RXIE;                          // Enable USCI0 RX interrupt
    c72e:	e2 d2 01 00 	bis.b	#4,	&0x0001	;r2 As==10

0000c732 <.Loc.217.1>:

//  SLAVE_CS_DIR |= SLAVE_CS_PIN;
//  SLAVE_CS_OUT |= SLAVE_CS_PIN;

}
    c732:	30 41       	ret			

0000c734 <USCIB0RX_ISR>:
#elif defined(__GNUC__)
void __attribute__ ((interrupt(USCIAB0RX_VECTOR))) USCIB0RX_ISR (void)
#else
#error Compiler not supported!
#endif
{
    c734:	0f 12       	push	r15		;

0000c736 <.LCFI3>:
    c736:	0e 12       	push	r14		;

0000c738 <.LCFI4>:
    c738:	0d 12       	push	r13		;

0000c73a <.LCFI5>:
    c73a:	0c 12       	push	r12		;

0000c73c <.LCFI6>:
    if (IFG2 & UCB0RXIFG)
    c73c:	e2 b2 03 00 	bit.b	#4,	&0x0003	;r2 As==10
    c740:	13 24       	jz	$+40     	;abs 0xc768

0000c742 <.LBB23>:
    {
        uint8_t ucb0_rx_val = UCB0RXBUF;
    c742:	5d 42 6e 00 	mov.b	&0x006e,r13	;0x006e

0000c746 <.LVL23>:
        switch (MasterMode)
    c746:	1c 42 5a 02 	mov	&0x025a,r12	;0x025a
    c74a:	3c 90 03 00 	cmp	#3,	r12	;
    c74e:	11 24       	jz	$+36     	;abs 0xc772
    c750:	2c 92       	cmp	#4,	r12	;r2 As==10
    c752:	25 24       	jz	$+76     	;abs 0xc79e
    c754:	1c 93       	cmp	#1,	r12	;r3 As==01
    c756:	42 24       	jz	$+134    	;abs 0xc7dc

0000c758 <.Loc.326.1>:
                    SendUCB0Data(DUMMY);
                }
                break;

            default:
                __no_operation();
    c758:	03 43       	nop			

0000c75a <.L39>:
                break;
        }
        __delay_cycles(50);
    c75a:	0d 12       	push	r13		;
    c75c:	3d 40 0e 00 	mov	#14,	r13	;#0x000e

0000c760 <.L1^B1>:
    c760:	1d 83       	dec	r13		;
    c762:	fe 23       	jnz	$-2      	;abs 0xc760
    c764:	3d 41       	pop	r13		;
    c766:	03 43       	nop			

0000c768 <.L32>:
    }
}
    c768:	3c 41       	pop	r12		;

0000c76a <.LCFI7>:
    c76a:	3d 41       	pop	r13		;

0000c76c <.LCFI8>:
    c76c:	3e 41       	pop	r14		;

0000c76e <.LCFI9>:
    c76e:	3f 41       	pop	r15		;

0000c770 <.LCFI10>:
    c770:	00 13       	reti			

0000c772 <.L34>:
                if (TXByteCtr)
    c772:	5c 42 2d 02 	mov.b	&0x022d,r12	;0x022d

0000c776 <.Loc.294.1>:
    c776:	c2 93 2d 02 	cmp.b	#0,	&0x022d	;r3 As==00
    c77a:	23 24       	jz	$+72     	;abs 0xc7c2

0000c77c <.Loc.296.1>:
                  SendUCB0Data(TransmitBuffer[TransmitIndex++]);
    c77c:	5d 42 2c 02 	mov.b	&0x022c,r13	;0x022c

0000c780 <.LVL26>:
    c780:	4e 4d       	mov.b	r13,	r14	;
    c782:	5e 53       	inc.b	r14		;
    c784:	c2 4e 2c 02 	mov.b	r14,	&0x022c	;

0000c788 <.Loc.296.1>:
    c788:	5d 4d 2e 02 	mov.b	558(r13),r13	;0x0022e

0000c78c <.L42>:
    while (!(IFG2 & UCB0TXIFG));              // USCI_A0 TX buffer ready?
    c78c:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c790:	fd 27       	jz	$-4      	;abs 0xc78c

0000c792 <.Loc.163.1>:
    UCB0TXBUF = val;
    c792:	c2 4d 6f 00 	mov.b	r13,	&0x006f	;

0000c796 <.LBE24>:
                  TXByteCtr--;
    c796:	7c 53       	add.b	#-1,	r12	;r3 As==11
    c798:	c2 4c 2d 02 	mov.b	r12,	&0x022d	;
    c79c:	de 3f       	jmp	$-66     	;abs 0xc75a

0000c79e <.L35>:
                if (RXByteCtr)
    c79e:	5c 42 43 02 	mov.b	&0x0243,r12	;0x0243

0000c7a2 <.Loc.308.1>:
    c7a2:	c2 93 43 02 	cmp.b	#0,	&0x0243	;r3 As==00
    c7a6:	0d 24       	jz	$+28     	;abs 0xc7c2

0000c7a8 <.Loc.310.1>:
                    ReceiveBuffer[ReceiveIndex++] = ucb0_rx_val;
    c7a8:	5e 42 42 02 	mov.b	&0x0242,r14	;0x0242
    c7ac:	4f 4e       	mov.b	r14,	r15	;
    c7ae:	5f 53       	inc.b	r15		;
    c7b0:	c2 4f 42 02 	mov.b	r15,	&0x0242	;

0000c7b4 <.Loc.310.1>:
    c7b4:	ce 4d 44 02 	mov.b	r13,	580(r14); 0x0244

0000c7b8 <.Loc.312.1>:
                    RXByteCtr--;
    c7b8:	7c 53       	add.b	#-1,	r12	;r3 As==11
    c7ba:	c2 4c 43 02 	mov.b	r12,	&0x0243	;

0000c7be <.Loc.314.1>:
                if (RXByteCtr == 0)
    c7be:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    c7c0:	26 20       	jnz	$+78     	;abs 0xc80e

0000c7c2 <.L41>:
                  MasterMode = IDLE_MODE;
    c7c2:	82 43 5a 02 	mov	#0,	&0x025a	;r3 As==00

0000c7c6 <.Loc.303.1>:
                  __bic_SR_register_on_exit(CPUOFF);      // Exit LPM0
    c7c6:	b1 c0 10 00 	bic	#16,	8(r1)	;#0x0010
    c7ca:	08 00 

0000c7cc <.Loc.329.1>:
        __delay_cycles(50);
    c7cc:	0d 12       	push	r13		;
    c7ce:	3d 40 0e 00 	mov	#14,	r13	;#0x000e

0000c7d2 <.L1^B2>:
    c7d2:	1d 83       	dec	r13		;
    c7d4:	fe 23       	jnz	$-2      	;abs 0xc7d2
    c7d6:	3d 41       	pop	r13		;
    c7d8:	03 43       	nop			
    c7da:	c6 3f       	jmp	$-114    	;abs 0xc768

0000c7dc <.L65>:
                if (RXByteCtr)
    c7dc:	c2 93 43 02 	cmp.b	#0,	&0x0243	;r3 As==00
    c7e0:	1d 24       	jz	$+60     	;abs 0xc81c

0000c7e2 <.Loc.279.1>:
                    MasterMode = RX_DATA_MODE;   // Need to start receiving now
    c7e2:	a2 42 5a 02 	mov	#4,	&0x025a	;r2 As==10

0000c7e6 <.Loc.281.1>:
                    __delay_cycles(2000);
    c7e6:	0d 12       	push	r13		;
    c7e8:	3d 40 98 02 	mov	#664,	r13	;#0x0298

0000c7ec <.L1^B3>:
    c7ec:	1d 83       	dec	r13		;
    c7ee:	fe 23       	jnz	$-2      	;abs 0xc7ec
    c7f0:	3d 41       	pop	r13		;
    c7f2:	03 43       	nop			

0000c7f4 <.L38>:
    while (!(IFG2 & UCB0TXIFG));              // USCI_A0 TX buffer ready?
    c7f4:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c7f8:	fd 27       	jz	$-4      	;abs 0xc7f4

0000c7fa <.L63>:
    UCB0TXBUF = val;
    c7fa:	f2 43 6f 00 	mov.b	#-1,	&0x006f	;r3 As==11

0000c7fe <.LBE28>:
        __delay_cycles(50);
    c7fe:	0d 12       	push	r13		;
    c800:	3d 40 0e 00 	mov	#14,	r13	;#0x000e

0000c804 <.L1^B4>:
    c804:	1d 83       	dec	r13		;
    c806:	fe 23       	jnz	$-2      	;abs 0xc804
    c808:	3d 41       	pop	r13		;
    c80a:	03 43       	nop			
    c80c:	ad 3f       	jmp	$-164    	;abs 0xc768

0000c80e <.L45>:
    while (!(IFG2 & UCB0TXIFG));              // USCI_A0 TX buffer ready?
    c80e:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c812:	f3 23       	jnz	$-24     	;abs 0xc7fa

0000c814 <.Loc.162.1>:
    c814:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c818:	fa 27       	jz	$-10     	;abs 0xc80e
    c81a:	ef 3f       	jmp	$-32     	;abs 0xc7fa

0000c81c <.L37>:
                    MasterMode = TX_DATA_MODE;        // Continue to transmision with the data in Transmit Buffer
    c81c:	b2 40 03 00 	mov	#3,	&0x025a	;
    c820:	5a 02 

0000c822 <.Loc.288.1>:
                    SendUCB0Data(TransmitBuffer[TransmitIndex++]);
    c822:	5c 42 2c 02 	mov.b	&0x022c,r12	;0x022c
    c826:	4d 4c       	mov.b	r12,	r13	;

0000c828 <.LVL32>:
    c828:	5d 53       	inc.b	r13		;
    c82a:	c2 4d 2c 02 	mov.b	r13,	&0x022c	;

0000c82e <.Loc.288.1>:
    c82e:	5c 4c 2e 02 	mov.b	558(r12),r12	;0x0022e

0000c832 <.L40>:
    while (!(IFG2 & UCB0TXIFG));              // USCI_A0 TX buffer ready?
    c832:	f2 b2 03 00 	bit.b	#8,	&0x0003	;r2 As==11
    c836:	fd 27       	jz	$-4      	;abs 0xc832

0000c838 <.Loc.163.1>:
    UCB0TXBUF = val;
    c838:	c2 4c 6f 00 	mov.b	r12,	&0x006f	;

0000c83c <.LBE32>:
                    TXByteCtr--;
    c83c:	f2 53 2d 02 	add.b	#-1,	&0x022d	;r3 As==11
    c840:	8c 3f       	jmp	$-230    	;abs 0xc75a

0000c842 <Port_1>:
#else
#error Compiler not supported!
#endif
{
//    P1OUT |= BIT6;
    P1IFG &= ~BIT3;                           // P1.3 IFG cleared
    c842:	f2 c2 23 00 	bic.b	#8,	&0x0023	;r2 As==11

0000c846 <.Loc.350.1>:
    P1IE &= ~BIT3;
    c846:	f2 c2 25 00 	bic.b	#8,	&0x0025	;r2 As==11

0000c84a <.Loc.352.1>:
    //Initiate
    __bic_SR_register_on_exit(LPM0_bits);      // Exit LPM0
    c84a:	b1 c0 10 00 	bic	#16,	0(r1)	;#0x0010
    c84e:	00 00 

0000c850 <.Loc.353.1>:
}
    c850:	00 13       	reti			

0000c852 <SPI_WriteReg>:
uint8_t MCP23S17_Init3[ INIT3_LEN ] = { 0x12, 0x08, 0x80 };
// GPIOA |     0|     0|     0|     0|     0|     0|     0|     0
// GPIOB |     0|     0|     0|     0|     0|     0|     0|     0

SPI_Mode SPI_WriteReg( uint8_t chip_addr, uint8_t reg_addr, uint8_t *reg_data, uint8_t count )
{
    c852:	4b 4d       	mov.b	r13,	r11	;
    c854:	0d 4e       	mov	r14,	r13	;

0000c856 <.LVL1>:
  P2OUT |= chip_addr & 0x07;
    c856:	7c f0 07 00 	and.b	#7,	r12	;

0000c85a <.LVL2>:
    c85a:	c2 dc 29 00 	bis.b	r12,	&0x0029	;

0000c85e <.Loc.26.1>:
  SPI_Master_WriteReg( reg_addr, reg_data, count );
    c85e:	4e 4f       	mov.b	r15,	r14	;

0000c860 <L0^A>:
    c860:	4c 4b       	mov.b	r11,	r12	;
    c862:	b0 12 34 c6 	call	#-14796	;#0xc634

0000c866 <.LVL4>:
  P2OUT &= 0x0F8;
    c866:	f2 f0 f8 ff 	and.b	#-8,	&0x0029	;#0xfff8
    c86a:	29 00 

0000c86c <.Loc.28.1>:
  return MasterMode;
}
    c86c:	1c 42 5a 02 	mov	&0x025a,r12	;0x025a
    c870:	30 41       	ret			

0000c872 <SPI_ReadReg>:

SPI_Mode SPI_ReadReg( uint8_t chip_addr, uint8_t reg_addr, uint8_t count )
{
    c872:	4f 4d       	mov.b	r13,	r15	;

0000c874 <.Loc.33.1>:
  P2OUT |= chip_addr & 0x07;
    c874:	7c f0 07 00 	and.b	#7,	r12	;

0000c878 <.LVL6>:
    c878:	c2 dc 29 00 	bis.b	r12,	&0x0029	;

0000c87c <.Loc.34.1>:
  SPI_Master_ReadReg( reg_addr, count );
    c87c:	4d 4e       	mov.b	r14,	r13	;

0000c87e <.LVL7>:
    c87e:	4c 4f       	mov.b	r15,	r12	;
    c880:	b0 12 8a c6 	call	#-14710	;#0xc68a

0000c884 <.LVL8>:
  P2OUT &= 0x0F8;
    c884:	f2 f0 f8 ff 	and.b	#-8,	&0x0029	;#0xfff8
    c888:	29 00 

0000c88a <.Loc.36.1>:
  return MasterMode;
}
    c88a:	1c 42 5a 02 	mov	&0x025a,r12	;0x025a
    c88e:	30 41       	ret			

0000c890 <InitSPI_FrontEnd_GPIO>:

void InitSPI_FrontEnd_GPIO( void )
{
  P2DIR |= BIT0 | BIT1 | BIT2;
    c890:	f2 d0 07 00 	bis.b	#7,	&0x002a	;
    c894:	2a 00 

0000c896 <.Loc.42.1>:
  P2OUT &= 0x0F8;
    c896:	f2 f0 f8 ff 	and.b	#-8,	&0x0029	;#0xfff8
    c89a:	29 00 

0000c89c <.Loc.43.1>:
}
    c89c:	30 41       	ret			

0000c89e <__mspabi_func_epilog_7>:
    c89e:	34 41       	pop	r4		;

0000c8a0 <__mspabi_func_epilog_6>:
    c8a0:	35 41       	pop	r5		;

0000c8a2 <__mspabi_func_epilog_5>:
    c8a2:	36 41       	pop	r6		;

0000c8a4 <__mspabi_func_epilog_4>:
    c8a4:	37 41       	pop	r7		;

0000c8a6 <__mspabi_func_epilog_3>:
    c8a6:	38 41       	pop	r8		;

0000c8a8 <__mspabi_func_epilog_2>:
    c8a8:	39 41       	pop	r9		;

0000c8aa <__mspabi_func_epilog_1>:
    c8aa:	3a 41       	pop	r10		;
    c8ac:	30 41       	ret			

0000c8ae <memcpy>:
    c8ae:	0a 12       	push	r10		;

0000c8b0 <.LCFI0>:
    c8b0:	4f 43       	clr.b	r15		;

0000c8b2 <.L2>:
    c8b2:	0e 9f       	cmp	r15,	r14	;
    c8b4:	02 20       	jnz	$+6      	;abs 0xc8ba

0000c8b6 <.Loc.111.1>:
    c8b6:	3a 41       	pop	r10		;

0000c8b8 <.LCFI1>:
    c8b8:	30 41       	ret			

0000c8ba <.L3>:
    c8ba:	0b 4c       	mov	r12,	r11	;
    c8bc:	0b 5f       	add	r15,	r11	;

0000c8be <.Loc.67.1>:
    c8be:	0a 4d       	mov	r13,	r10	;
    c8c0:	0a 5f       	add	r15,	r10	;

0000c8c2 <.Loc.67.1>:
    c8c2:	eb 4a 00 00 	mov.b	@r10,	0(r11)	;
    c8c6:	1f 53       	inc	r15		;

0000c8c8 <.LVL4>:
    c8c8:	f4 3f       	jmp	$-22     	;abs 0xc8b2

0000c8ca <memmove>:
    c8ca:	0a 12       	push	r10		;

0000c8cc <L0^A>:
    c8cc:	09 12       	push	r9		;

0000c8ce <.LCFI1>:
    c8ce:	0d 9c       	cmp	r12,	r13	;
    c8d0:	1d 2c       	jc	$+60     	;abs 0xc90c

0000c8d2 <.Loc.69.1>:
    c8d2:	0a 4d       	mov	r13,	r10	;
    c8d4:	0a 5e       	add	r14,	r10	;

0000c8d6 <.Loc.69.1>:
    c8d6:	0c 9a       	cmp	r10,	r12	;
    c8d8:	19 2c       	jc	$+52     	;abs 0xc90c

0000c8da <.LVL2>:
    c8da:	09 4e       	mov	r14,	r9	;
    c8dc:	39 e3       	inv	r9		;

0000c8de <.Loc.74.1>:
    c8de:	4d 43       	clr.b	r13		;

0000c8e0 <.L3>:
    c8e0:	3d 53       	add	#-1,	r13	;r3 As==11

0000c8e2 <.LVL4>:
    c8e2:	09 9d       	cmp	r13,	r9	;
    c8e4:	01 20       	jnz	$+4      	;abs 0xc8e8

0000c8e6 <.L10>:
    c8e6:	e0 3f       	jmp	$-62     	;abs 0xc8a8

0000c8e8 <.L4>:
    c8e8:	0f 4e       	mov	r14,	r15	;
    c8ea:	0f 5d       	add	r13,	r15	;
    c8ec:	0f 5c       	add	r12,	r15	;
    c8ee:	0b 4a       	mov	r10,	r11	;
    c8f0:	0b 5d       	add	r13,	r11	;

0000c8f2 <.LVL7>:
    c8f2:	ef 4b 00 00 	mov.b	@r11,	0(r15)	;
    c8f6:	f4 3f       	jmp	$-22     	;abs 0xc8e0

0000c8f8 <.L6>:
    c8f8:	0b 4d       	mov	r13,	r11	;
    c8fa:	0b 5f       	add	r15,	r11	;

0000c8fc <.Loc.83.1>:
    c8fc:	0a 4c       	mov	r12,	r10	;
    c8fe:	0a 5f       	add	r15,	r10	;
    c900:	ea 4b 00 00 	mov.b	@r11,	0(r10)	;
    c904:	1f 53       	inc	r15		;

0000c906 <.L5>:
    c906:	0e 9f       	cmp	r15,	r14	;
    c908:	f7 23       	jnz	$-16     	;abs 0xc8f8
    c90a:	ed 3f       	jmp	$-36     	;abs 0xc8e6

0000c90c <.L9>:
    c90c:	4f 43       	clr.b	r15		;
    c90e:	fb 3f       	jmp	$-8      	;abs 0xc906

0000c910 <memset>:
    c910:	0e 5c       	add	r12,	r14	;

0000c912 <.LVL2>:
    c912:	0f 4c       	mov	r12,	r15	;

0000c914 <.L2>:
    c914:	0f 9e       	cmp	r14,	r15	;
    c916:	01 20       	jnz	$+4      	;abs 0xc91a

0000c918 <L0^A>:
    c918:	30 41       	ret			

0000c91a <.L3>:
    c91a:	1f 53       	inc	r15		;

0000c91c <.LVL4>:
    c91c:	cf 4d ff ff 	mov.b	r13,	-1(r15)	; 0xffff
    c920:	f9 3f       	jmp	$-12     	;abs 0xc914
